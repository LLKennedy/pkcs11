package p11

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/llkennedy/pkcs11"
)

// Session represents a PKCS#11 session.
type Session interface {
	// Login logs into the token as a regular user. Note: According to PKCS#11,
	// logged-in state is a property of an application, rather than a session, but
	// you can only log in via a session. Keep this in mind when using multiple
	// sessions on the same token. Logging in to a token in any session will log
	// in all sessions on that token, and logging out will do the same. This is
	// particularly relevant for private keys with CKA_ALWAYS_AUTHENTICATE set
	// (like Yubikeys in PIV mode). See
	// https://github.com/letsencrypt/pkcs11key/blob/master/key.go for an example
	// of managing login state with a mutex.
	Login(pin string) error
	// LoginSecurityOfficer logs into the token as the security officer.
	LoginSecurityOfficer(pin string) error
	// LoginAs logs into the token with the given user type.
	LoginAs(userType uint, pin string) error
	// Logout logs out all sessions from the token (see Login).
	Logout() error
	// Close closes the session.
	Close() error

	// CreateObject creates an object on the token with the given attributes.
	CreateObject(template []*pkcs11.Attribute) (Object, error)
	// FindObject finds a single object in the token that matches the attributes in
	// the template. It returns error if there is not exactly one result, or if
	// there was an error during the find calls.
	FindObject(template []*pkcs11.Attribute) (Object, error)
	// FindObjects finds any objects in the token matching the template.
	FindObjects(template []*pkcs11.Attribute) ([]Object, error)
	// GenerateKeyPair generates a public/private key pair. It takes
	// GenerateKeyPairRequest instead of individual arguments so that attributes for
	// public and private keys can't be accidentally switched around.
	GenerateKeyPair(request GenerateKeyPairRequest) (*KeyPair, error)
	// GenerateRandom returns random bytes generated by the token.
	GenerateRandom(length int) ([]byte, error)
	// GenerateKey generates a secret key.
	GenerateKey(request GenerateKeyRequest) (*SecretKey, error)
	// Encrypt encrypts data
	Encrypt(encryptionKey Object, m []*pkcs11.Mechanism, message []byte) ([]byte, error)
	// EncryptSegmented encrypts multiple data segments individually then one final one, for those few mechanisms where it matters
	EncryptSegmented(ctx context.Context, encryptionKey Object, m []*pkcs11.Mechanism, messageParts <-chan []byte, final <-chan struct{}) (<-chan []byte, <-chan error)
	// Decrypt decrypts data
	Decrypt(encryptionKey Object, m []*pkcs11.Mechanism, message []byte) ([]byte, error)
	// DecryptSegmented decrypts multiple data segments individually then one final one, for those few mechanisms where it matters
	DecryptSegmented(ctx context.Context, encryptionKey Object, m []*pkcs11.Mechanism, messageParts <-chan []byte, final <-chan struct{}) (<-chan []byte, <-chan error)
	// Sign signs a message
	Sign(signingKey Object, m []*pkcs11.Mechanism, message []byte) ([]byte, error)
	// SignSegmented signs multiple data segments individually then one final part, for those few mechanisms where it matters
	SignSegmented(ctx context.Context, signingKey Object, m []*pkcs11.Mechanism, messageParts <-chan []byte, final <-chan struct{}) (<-chan []byte, <-chan error)
	// Verify verifies a message and signature
	Verify(verificationKey Object, m []*pkcs11.Mechanism, message []byte, signature []byte) error
	// Verify verifies multiple data segments individually then the final signature, for those  few mechanisms where it matters.
	VerifySegmented(ctx context.Context, verificationKey Object, m []*pkcs11.Mechanism, messageParts, signature <-chan []byte) <-chan error
	// WrapKey wraps a key
	WrapKey(wrappingkey Object, m []*pkcs11.Mechanism, key Object) ([]byte, error)
	// UnwrapKey unwraps a key
	UnwrapKey(unwrappingkey Object, m []*pkcs11.Mechanism, wrappedkey []byte, a []*pkcs11.Attribute) (*Object, error)
	// DestroyObject destroys an object
	DestroyObject(Object) error
	// CopyObject copies an object with new attributes if possible
	CopyObject(o Object, temp []*pkcs11.Attribute) (*Object, error)

	// InitPIN initialize's the normal user's PIN.
	InitPIN(pin string) error
	// SetPIN modifies the PIN of the logged-in user. "old" should contain the
	// current PIN, and "new" should contain the new PIN to be set.
	SetPIN(old, new string) error
}

var _ Session = &sessionImpl{}

type sessionImpl struct {
	sync.Mutex
	ctx    *pkcs11.Ctx
	handle pkcs11.SessionHandle
}

func (s *sessionImpl) FindPrivateKey(label string) (PrivateKey, error) {
	obj, err := s.findObjectWithClassAndLabel(pkcs11.CKO_PRIVATE_KEY, label)
	if err != nil {
		return PrivateKey(obj), err
	}
	return PrivateKey(obj), nil
}

func (s *sessionImpl) FindPublicKey(label string) (PublicKey, error) {
	obj, err := s.findObjectWithClassAndLabel(pkcs11.CKO_PUBLIC_KEY, label)
	if err != nil {
		return PublicKey(obj), err
	}
	return PublicKey(obj), nil
}

func (s *sessionImpl) FindSecretKey(label string) (SecretKey, error) {
	obj, err := s.findObjectWithClassAndLabel(pkcs11.CKO_SECRET_KEY, label)
	if err != nil {
		return SecretKey(obj), err
	}
	return SecretKey(obj), nil
}

func (s *sessionImpl) findObjectWithClassAndLabel(class uint, label string) (Object, error) {
	return s.FindObject([]*pkcs11.Attribute{
		pkcs11.NewAttribute(pkcs11.CKA_CLASS, class),
		pkcs11.NewAttribute(pkcs11.CKA_LABEL, label),
	})
}

func (s *sessionImpl) FindObject(template []*pkcs11.Attribute) (Object, error) {
	objects, err := s.FindObjects(template)
	if err != nil {
		return Object{}, err
	}
	if len(objects) > 1 {
		return Object{}, errors.New("too many objects matching template")
	}
	return objects[0], nil
}

func (s *sessionImpl) FindObjects(template []*pkcs11.Attribute) ([]Object, error) {
	s.Lock()
	defer s.Unlock()
	if err := s.ctx.FindObjectsInit(s.handle, template); err != nil {
		return nil, err
	}

	var results []Object
	for {
		objectHandles, _, err := s.ctx.FindObjects(s.handle, 100)
		if err != nil {
			_ = s.ctx.FindObjectsFinal(s.handle)
			return nil, err
		} else if len(objectHandles) == 0 {
			break
		}
		i := len(results)
		results = append(results, make([]Object, len(objectHandles))...)
		for j, objectHandle := range objectHandles {
			results[i+j] = Object{
				session:      s,
				objectHandle: objectHandle,
			}
		}
	}
	if err := s.ctx.FindObjectsFinal(s.handle); err != nil {
		return nil, err
	} else if len(results) == 0 {
		return nil, errors.New("no objects found")
	}
	return results, nil
}

func (s *sessionImpl) Close() error {
	s.Lock()
	defer s.Unlock()
	return s.ctx.CloseSession(s.handle)
}

func (s *sessionImpl) Login(pin string) error {
	return s.LoginAs(pkcs11.CKU_USER, pin)
}

func (s *sessionImpl) LoginSecurityOfficer(pin string) error {
	return s.LoginAs(pkcs11.CKU_SO, pin)
}

func (s *sessionImpl) LoginAs(userType uint, pin string) error {
	s.Lock()
	defer s.Unlock()
	return s.ctx.Login(s.handle, userType, pin)
}

func (s *sessionImpl) Logout() error {
	s.Lock()
	defer s.Unlock()
	return s.ctx.Logout(s.handle)
}

func (s *sessionImpl) GenerateRandom(length int) ([]byte, error) {
	s.Lock()
	defer s.Unlock()
	return s.ctx.GenerateRandom(s.handle, length)
}

func (s *sessionImpl) CreateObject(template []*pkcs11.Attribute) (Object, error) {
	s.Lock()
	defer s.Unlock()
	oh, err := s.ctx.CreateObject(s.handle, template)
	if err != nil {
		return Object{}, err
	}
	return Object{
		session:      s,
		objectHandle: oh,
	}, nil
}

func (s *sessionImpl) InitPIN(pin string) error {
	s.Lock()
	defer s.Unlock()
	return s.ctx.InitPIN(s.handle, pin)
}

func (s *sessionImpl) SetPIN(old, new string) error {
	s.Lock()
	defer s.Unlock()
	return s.ctx.SetPIN(s.handle, old, new)
}

// KeyPair contains two Objects: one for a public key and one for a private key.
// It represents these as PublicKey and PrivateKey types so they can by used for
// appropriate cryptographic operations.
type KeyPair struct {
	Public  PublicKey
	Private PrivateKey
}

// GenerateKeyPairRequest contains the fields used to generate a key pair.
type GenerateKeyPairRequest struct {
	Mechanism            pkcs11.Mechanism
	PublicKeyAttributes  []*pkcs11.Attribute
	PrivateKeyAttributes []*pkcs11.Attribute
}

func (s *sessionImpl) GenerateKeyPair(request GenerateKeyPairRequest) (*KeyPair, error) {
	s.Lock()
	defer s.Unlock()
	pubHandle, privHandle, err := s.ctx.GenerateKeyPair(s.handle,
		[]*pkcs11.Mechanism{&request.Mechanism},
		request.PublicKeyAttributes,
		request.PrivateKeyAttributes)
	if err != nil {
		return nil, err
	}
	return &KeyPair{
		Public: PublicKey(Object{
			session:      s,
			objectHandle: pubHandle,
		}),
		Private: PrivateKey(Object{
			session:      s,
			objectHandle: privHandle,
		}),
	}, nil
}

// GenerateKeyRequest contains the fields used to generate a key.
type GenerateKeyRequest struct {
	Mechanism     pkcs11.Mechanism
	KeyAttributes []*pkcs11.Attribute
}

func (s *sessionImpl) GenerateKey(request GenerateKeyRequest) (*SecretKey, error) {
	s.Lock()
	defer s.Unlock()
	newHandle, err := s.ctx.GenerateKey(s.handle,
		[]*pkcs11.Mechanism{&request.Mechanism},
		request.KeyAttributes,
	)
	if err != nil {
		return nil, err
	}
	return (*SecretKey)(&Object{
		session:      s,
		objectHandle: newHandle,
	}), nil
}

func (s *sessionImpl) WrapKey(wrappingkey Object, m []*pkcs11.Mechanism, key Object) ([]byte, error) {
	s.Lock()
	defer s.Unlock()
	return s.ctx.WrapKey(s.handle, m, wrappingkey.objectHandle, key.objectHandle)
}

func (s *sessionImpl) UnwrapKey(unwrappingkey Object, m []*pkcs11.Mechanism, wrappedkey []byte, a []*pkcs11.Attribute) (*Object, error) {
	s.Lock()
	defer s.Unlock()
	obj, err := s.ctx.UnwrapKey(s.handle, m, unwrappingkey.objectHandle, wrappedkey, a)
	if err != nil {
		return nil, err
	}
	return &Object{
		session:      s,
		objectHandle: obj,
	}, nil
}

func (s *sessionImpl) DestroyObject(o Object) error {
	s.Lock()
	defer s.Unlock()
	return s.ctx.DestroyObject(s.handle, o.objectHandle)
}

func (s *sessionImpl) CopyObject(o Object, temp []*pkcs11.Attribute) (*Object, error) {
	s.Lock()
	defer s.Unlock()
	obj, err := s.ctx.CopyObject(s.handle, o.objectHandle, temp)
	if err != nil {
		return nil, err
	}
	return &Object{
		session:      s,
		objectHandle: obj,
	}, nil
}

func (s *sessionImpl) Encrypt(encryptionKey Object, m []*pkcs11.Mechanism, message []byte) ([]byte, error) {
	s.Lock()
	defer s.Unlock()
	err := s.ctx.EncryptInit(s.handle, m, encryptionKey.objectHandle)
	if err != nil {
		return nil, err
	}
	return s.ctx.Encrypt(s.handle, message)
}

func (s *sessionImpl) EncryptSegmented(ctx context.Context, encryptionKey Object, m []*pkcs11.Mechanism, messageParts <-chan []byte, final <-chan struct{}) (<-chan []byte, <-chan error) {
	resOut := make(chan []byte, 1000)
	errOut := make(chan error, 1)
	done := ctx.Done()
	go func() {
		s.Lock()
		defer s.Unlock()
		defer close(resOut)
		defer close(errOut)
		err := s.ctx.EncryptInit(s.handle, m, encryptionKey.objectHandle)
		if err != nil {
			errOut <- err
			return
		}
		for {
			select {
			case <-done:
				errOut <- fmt.Errorf("context canceled")
				return
			case <-final:
				dataFinal, err := s.ctx.EncryptFinal(s.handle)
				if err != nil {
					errOut <- err
					return
				}
				resOut <- dataFinal
			case messagePart := <-messageParts:
				data, err := s.ctx.EncryptUpdate(s.handle, messagePart)
				if err != nil {
					errOut <- err
					return
				}
				resOut <- data
			}
		}
	}()
	return resOut, errOut
}

func (s *sessionImpl) Decrypt(encryptionKey Object, m []*pkcs11.Mechanism, message []byte) ([]byte, error) {
	s.Lock()
	defer s.Unlock()
	err := s.ctx.DecryptInit(s.handle, m, encryptionKey.objectHandle)
	if err != nil {
		return nil, err
	}
	return s.ctx.Decrypt(s.handle, message)
}

func (s *sessionImpl) DecryptSegmented(ctx context.Context, encryptionKey Object, m []*pkcs11.Mechanism, messageParts <-chan []byte, final <-chan struct{}) (<-chan []byte, <-chan error) {
	resOut := make(chan []byte, 1000)
	errOut := make(chan error, 1)
	done := ctx.Done()
	go func() {
		s.Lock()
		defer s.Unlock()
		defer close(resOut)
		defer close(errOut)
		err := s.ctx.DecryptInit(s.handle, m, encryptionKey.objectHandle)
		if err != nil {
			errOut <- err
			return
		}
		for {
			select {
			case <-done:
				errOut <- fmt.Errorf("context canceled")
				return
			case <-final:
				dataFinal, err := s.ctx.DecryptFinal(s.handle)
				if err != nil {
					errOut <- err
					return
				}
				resOut <- dataFinal
			case messagePart := <-messageParts:
				data, err := s.ctx.DecryptUpdate(s.handle, messagePart)
				if err != nil {
					errOut <- err
					return
				}
				resOut <- data
			}
		}
	}()
	return resOut, errOut
}

func (s *sessionImpl) Sign(signingKey Object, m []*pkcs11.Mechanism, message []byte) ([]byte, error) {
	s.Lock()
	defer s.Unlock()
	err := s.ctx.SignInit(s.handle, m, signingKey.objectHandle)
	if err != nil {
		return nil, err
	}
	return s.ctx.Sign(s.handle, message)
}

func (s *sessionImpl) SignSegmented(ctx context.Context, signingKey Object, m []*pkcs11.Mechanism, messageParts <-chan []byte, final <-chan struct{}) (<-chan []byte, <-chan error) {
	resOut := make(chan []byte, 1)
	errOut := make(chan error, 1)
	done := ctx.Done()
	go func() {
		s.Lock()
		defer s.Unlock()
		defer close(resOut)
		defer close(errOut)
		err := s.ctx.SignInit(s.handle, m, signingKey.objectHandle)
		if err != nil {
			errOut <- err
			return
		}
		for {
			select {
			case <-done:
				errOut <- fmt.Errorf("context canceled")
				return
			case <-final:
				dataFinal, err := s.ctx.SignFinal(s.handle)
				if err != nil {
					errOut <- err
					return
				}
				resOut <- dataFinal
			case messagePart := <-messageParts:
				err := s.ctx.SignUpdate(s.handle, messagePart)
				if err != nil {
					errOut <- err
					return
				}
			}
		}
	}()
	return resOut, errOut
}

func (s *sessionImpl) Verify(verificationKey Object, m []*pkcs11.Mechanism, message []byte, signature []byte) error {
	s.Lock()
	defer s.Unlock()
	err := s.ctx.VerifyInit(s.handle, m, verificationKey.objectHandle)
	if err != nil {
		return err
	}
	return s.ctx.Verify(s.handle, message, signature)
}

func (s *sessionImpl) VerifySegmented(ctx context.Context, verificationKey Object, m []*pkcs11.Mechanism, messageParts, signature <-chan []byte) <-chan error {
	errOut := make(chan error, 1)
	done := ctx.Done()
	go func() {
		s.Lock()
		defer s.Unlock()
		defer close(errOut)
		err := s.ctx.VerifyInit(s.handle, m, verificationKey.objectHandle)
		if err != nil {
			errOut <- err
			return
		}
		for {
			select {
			case <-done:
				errOut <- fmt.Errorf("context canceled")
				return
			case sig := <-signature:
				errOut <- s.ctx.VerifyFinal(s.handle, sig)
				return
			case messagePart := <-messageParts:
				err := s.ctx.VerifyUpdate(s.handle, messagePart)
				if err != nil {
					errOut <- err
					return
				}
			}
		}
	}()
	return errOut
}
